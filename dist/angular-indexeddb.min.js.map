{"version":3,"sources":["angular-indexeddb.min.js","angular-indexeddb.js"],"names":["indexeddbProvider","$windowProvider","initialize","$q","CreateDB","name","version","_check","self","indexdb","$window","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","keyRange","IDBKeyRange","mozIDBKeyRange","webkitIDBKeyRange","msIDBKeyRange","this","open","Promise","resolve","reject","connection","onupgradeneeded","event","onerror","onsuccess","openConnection","DBHelper","helper","helperObject","isDesc","changeCase","value","toUpper","caseInsensitive","undefined","toUpperCase","toLowerCase","checkLikeString","recordKey","likeString","key","angular","copy","toString","match","whereIn","result","whereInValues","resultKey","isInValue","forEach","lowerValue","indexOf","setOrderSettings","inValues","isNumber","sort","_sortAsNumbers","reverse","sortAsNumbers","a","b","whereNotIn","exists","getPropertyValue","property","i","properties","propertyValue","split","length","maxValue","value1","value2","minValue","CreateTables","tables","qRes","qRej","CreateModelBuilder","table","_defaultModelSettings","model","bound","index","hasFilter","filterFunction","whereNotInValues","withTables","hasWith","traverse","isWhereNumber","originalWithRelation","_setWithRelation","relations","Object","keys","tableName","withTable","filter","exisitingTable","gt","lower","lowerBound","gte","lte","upper","upperBound","lt","orderDesc","select","fields","keyPathField","equal","where","only","setCaseInsensitive","incUpper","incLower","lowerOpen","upperOpen","between","notInValues","like","withRelations","withRelation","CreateAggregateBuilder","aggregate","sums","mins","maxs","averages","customs","call","sum","push","min","max","average","custom","callback","endCallback","customObject","testDuplicate","CreateOtherBuilder","andObject","orObject","inObject","notInObject","likeObject","gtObject","gteObject","ltObject","lteObject","apply","whereOtherAnd","propertyName","whereOtherOr","whereOtherIn","constructor","Array","whereOtherNotIn","whereOtherLike","whereOtherGt","whereOtherGte","whereOtherLte","whereOtherLt","CreateModel","_checkResult","andStatus","orStatus","hasAnd","_getTransactionTables","transactionTables","_get","readwrite","write","then","db","target","transaction","splice","objectStore","openCursor","exception","abort","error","_updateValue","data","hasTimeStamp","newValue","updatedAt","Date","parse","CreateAggregate","count","c","m","outcome","cust","withRelationObject","aggregateObject","getRelationData","isFind","_id","setOutcome","withTableName","relationsData","tableSchema","tableObject","Relations","relationData","outcomeData","getWithAllData","objectStoreTables","withTablesCount","relationNames","currentCount","field","currentOutcome","cursor","e","getSums","getMins","getMaxs","getAverages","resultOrCount","finalCalculation","getCustoms","update","record","relation","add","manyOutcome","isMany","many","newObjectStore","put","destroy","isDestroy","find","getId","get","createdAt","srcElement","addMultiple","inserted","toAddData","getAll","Error","objectStoreDelete","deleteId","deletedIds","del","getAggregate","ag","_getFieldConfig","config","hasOwnProperty","unique","multiEntry","_getIndexValue","keyPathValue","_createModelInstance","objectStoreNames","contains","keyPath","models","defineProperty","_createTables","other","indexValue","indexNames","createIndex","createObjectStore","autoIncrement","_setFields","j","newFields","fieldNames","_setTables","tableNames","timeStamps","indexOnTimeStamps","l","type","res","rej","dbName","dbVersion","dbTables","setDbName","setDbTables","setDbVersion","$get","$inject","module","provider"],"mappings":"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","file":"angular-indexeddb.min.js","sourcesContent":[null,"/*jslint browser: true*/\n/*global $q */\nfunction indexeddbProvider($windowProvider) {\n    'use strict';\n    var $window = $windowProvider.$get();\n\n    var dbName, dbVersion, dbTables;\n    dbName = 'test';\n    dbVersion = 1;\n    dbTables = [];\n\n\n    function initialize($q) {\n        /**\n         * Class : Function creates database and provides $q when database connection is resolved\n         * @param {string} name    [name of database]\n         * @param {integer} version [contains version number]\n         */\n        function CreateDB(name, version) {\n            var self = this;\n            self.name = name;\n            self.version = version;\n            self.indexdb = \"\";\n\n            /**\n             * Private : checks whether indexdb is supported by browser or not\n             */\n            function _check() {\n                self.indexdb = $window.indexedDB || $window.mozIndexedDB || $window.webkitIndexedDB || $window.msIndexedDB;\n                if (typeof self.indexdb !== \"object\") {\n                    throw \"IndexedDB not supported\";\n                }\n                self.keyRange = $window.IDBKeyRange || $window.mozIDBKeyRange || $window.webkitIDBKeyRange || $window.msIDBKeyRange;\n            }\n\n            _check();\n\n            //connection opening for updating database\n            self.open = new $window.Promise(function (resolve, reject) {\n\n                var connection = self.indexdb.open(self.name, self.version);\n                connection.onupgradeneeded = function (event) {\n                    resolve(event);\n                };\n                connection.onerror = function (event) {\n                    reject(event);\n                };\n\n                connection.onsuccess = function (event) {\n                    resolve(event);\n                };\n            });\n\n            //open database in default version\n            self.openConnection = new $window.Promise(function (resolve, reject) {\n\n                var connection = self.indexdb.open(self.name);\n                connection.onerror = function (event) {\n                    reject(event);\n                };\n\n                connection.onsuccess = function (event) {\n                    resolve(event);\n                };\n            });\n        }\n\n        /**\n         * Class : Helper class with various helper functions\n         */\n        function DBHelper() {\n            var helper = this;\n            var helperObject = {};\n            helperObject.isDesc = false;\n\n            //function changes case of value if string type to lower or upper\n            helper.changeCase = function (value, toUpper, caseInsensitive) {\n                toUpper = (toUpper === undefined) ? false : toUpper;\n                if (caseInsensitive) {\n                    if (typeof value === 'string') {\n                        value = (toUpper === true) ? value.toUpperCase() : value.toLowerCase();\n                    }\n                }\n\n                return value;\n            };\n\n            //function checks for like functionality in record key value\n            helper.checkLikeString = function (recordKey, likeString, caseInsensitive) {\n                var key = angular.copy(recordKey);\n                key = key.toString();\n\n                //if case insensitive\n                if (caseInsensitive) {\n                    key = key.toLowerCase();\n                    return (key.match(likeString.toLowerCase()) !== null);\n                }\n\n                return (key.match(likeString) !== null);\n            };\n\n            /**\n             * The where in logic for the object store\n             * @param  {integer/string} result             [contains value to be checked against]\n             * @param  {array} whereInValues      [whereIn values to search for]\n             * @param  {boolean} useCaseInsensitive [override case sensitive search]\n             * @return {boolean}                    [true if exists in list]\n             */\n            helper.whereIn = function (result, whereInValues, caseInsensitive) {\n\n                caseInsensitive = (caseInsensitive === undefined) ? false : caseInsensitive;\n\n                //if case sensitive then checking throughout th database\n                if (caseInsensitive) {\n                    var resultKey, isInValue;\n                    isInValue = false;\n\n                    resultKey = helper.changeCase(result, false, true);\n\n                    //checking each where in value against the main result value both in lower case\n                    whereInValues.forEach(function (value) {\n                        var lowerValue = helper.changeCase(angular.copy(value), false, true);\n                        if (lowerValue === resultKey) {\n                            isInValue = true;\n                        }\n                    });\n\n                    return isInValue;\n                }\n\n                return (whereInValues.indexOf(result) !== -1);\n            };\n\n            helper.setOrderSettings = function (inValues, isNumber, isDesc) {\n                //setting wherein, where not in as values of is desc for sorting\n                if (isDesc) {\n                    helperObject.isDesc = true;\n                }\n\n                if (isNumber) {\n                    inValues = inValues.sort(helperObject._sortAsNumbers);\n\n                } else {\n                    inValues = (helperObject.isDesc) ? inValues.reverse() : inValues.sort();\n                }\n\n                helperObject.isDesc = false;\n                return inValues;\n            };\n\n            //sorting where in/ where not in as number\n            helper.sortAsNumbers = function (a, b) {\n\n                //if desc then returning b-a for descending values\n                if (helperObject.isDesc) {\n                    return (b - a);\n                }\n\n                //returning ascending values\n                return (a - b);\n            };\n\n            //function for where not in logic \n            helper.whereNotIn = function (result, inValues, caseInsensitive) {\n                //case sensitive\n                if (caseInsensitive) {\n                    var resultKey = helper.changeCase(result, false, true);\n                    var exists = false;\n\n                    inValues.forEach(function (value) {\n                        var lowerValue = helper.changeCase(angular.copy(value), false, true);\n\n                        //checking if current value doesn't exist in inValues while caseInsensitive\n                        if (lowerValue === resultKey) {\n                            exists = true;\n                        }\n                    });\n\n                    if (!exists) {\n                        return true;\n                    }\n\n                } else {\n                    if (inValues.indexOf(result) === -1) {\n                        return true;\n                    }\n                }\n\n                return false;\n            };\n\n            //function takes in string values in dotted format and returns the value at the result param\n            helper.getPropertyValue = function (property, result) {\n                var propertyValue = angular.copy(result);\n                var i, properties;\n                properties = property.split('.');\n\n                if (properties.length > 1) {\n                    for (i = 0; i <= properties.length - 1; i++) {\n                        //if any of the property value is undefined then returning\n                        if (propertyValue[properties[i]] === undefined) {\n                            return undefined;\n                        }\n                        propertyValue = propertyValue[properties[i]];\n                    }\n\n                } else {\n                    propertyValue = propertyValue[properties[0]];\n                }\n\n                return propertyValue;\n            };\n\n\n            //compares two values and returns the larger one\n            helper.maxValue = function (value1, value2) {\n                if (value1 >= value2) {\n                    return value1;\n                }\n\n                return value2;\n            };\n\n            //compares two values and returns the smaller one\n            helper.minValue = function (value1, value2) {\n                if (value1 <= value2) {\n                    return value1;\n                }\n\n                return value2;\n            };\n        }\n\n        /**\n         * Class : class for maintaining and creating tables\n         * @param {string} name    [database name]\n         * @param {integer} version [version of database]\n         * @param {array} tables  [contains tables to be created]\n         */\n        function CreateTables(name, version, tables, qRes, qRej) {\n            CreateDB.apply(this, [name, version]);\n            this.helper = {};\n            DBHelper.apply(this.helper, []);\n\n            var self = this;\n            self.tables = tables || [];\n            self.models = {};\n\n            /**\n             * Class : class for maintaining builder functions of model\n             * @param {array} table [table to act against] aggregate\n             */\n            function CreateModelBuilder(table) {\n                var model = this;\n\n                //private : function sets the model default settings\n                function _defaultModelSettings() {\n                    model.bound = null; //default bound value\n                    model.index = null; //default index value\n                    model.caseInsensitive = false; //default caseInsensitive value\n                    model.hasFilter = false; //default if model has filter\n                    model.filterFunction = null; //default filter function\n                    model.whereInValues = null; //default whereInValues for whereIn\n                    model.whereNotInValues = null; //default whereNotInValues for whereNotIn\n                    model.withTables = {}; //with tables structure\n                    model.hasWith = false; //default has with relation status\n                    model.isDesc = false; //default descending traverse set to false\n                    model.traverse = 'next'; //default traversing set to ascending\n                    model.isWhereNumber = false; //default where clause not containing number\n                    model.originalWithRelation = null; //default original with relation data\n                    model.likeString = null; //default likeString data\n                }\n\n                function _setWithRelation(relations) {\n                    var withTables = Object.keys(relations);\n\n                    withTables.forEach(function (tableName) {\n                        //creating model for each instance\n                        var withTable = self.tables.filter(function (exisitingTable) {\n                            return (exisitingTable.name === tableName);\n                        })[0];\n\n                        model.withTables[tableName] = new CreateModelBuilder(withTable);\n                    });\n                }\n\n                _defaultModelSettings();\n\n                //function sets greater than value for index\n                model.gt = function (lower) {\n                    lower = self.helper.changeCase(lower, true, model.caseInsensitive);\n                    model.bound = self.keyRange.lowerBound(lower, true);\n                    return model;\n                };\n\n                //function sets greater than value for index including the value\n                model.gte = function (lower) {\n                    lower = self.helper.changeCase(lower, true, model.caseInsensitive);\n                    model.bound = self.keyRange.lowerBound(lower);\n                    return model;\n                };\n\n                //function sets less than value for index including the value\n                model.lte = function (upper) {\n                    upper = self.helper.changeCase(upper, false, model.caseInsensitive);\n                    model.bound = self.keyRange.upperBound(upper);\n                    return model;\n                };\n\n                //function sets less than value for index\n                model.lt = function (upper) {\n                    upper = self.helper.changeCase(upper, false, model.caseInsensitive);\n                    model.bound = self.keyRange.upperBound(upper, true);\n                    return model;\n                };\n\n                //function traverse through reverse order i.e descending\n                model.orderDesc = function (isDesc) {\n                    model.isDesc = false;\n                    model.traverse = 'next';\n\n                    if (isDesc === true) {\n                        model.isDesc = true;\n                        model.traverse = 'prev';\n                    }\n\n                    if (model.whereInValues !== null) {\n                        model.whereInValues = self.helper.setOrderSettings(model.whereInValues, model.isWhereNumber, model.isDesc);\n                    }\n\n                    if (model.whereNotInValues !== null) {\n                        model.whereNotInValues = self.helper.setOrderSettings(model.whereNotInValues, model.isWhereNumber, model.isDesc);\n                    }\n\n                    return model;\n                };\n\n                //selecting index to make searches upon\n                model.select = function (index) {\n                    if (index === table.fields.keyPathField) {\n                        return model;\n                    }\n                    model.index = index;\n                    return model;\n                };\n\n                //function sets equal value for index searching (not case sensitive)\n                model.equal = function (where) {\n                    model.bound = self.keyRange.only(where);\n                    return model;\n                };\n\n                //sets searches to case sensitive\n                model.setCaseInsensitive = function (value) {\n                    var lower, upper, incUpper, incLower;\n\n                    value = (value === undefined || value === true) ? true : false;\n                    model.caseInsensitive = value;\n\n                    //if model has been set to case insensitive and bound values are defined then\n                    if (model.caseInsensitive && model.bound !== null) {\n\n                        //case not of equal\n                        if (model.bound.lower !== model.bound.upper) {\n\n                            //setting bound values against case insensitive\n                            lower = self.helper.changeCase(angular.copy(model.bound.lower), true, true);\n                            incLower = (model.bound.lowerOpen === undefined) ? false : angular.copy(model.bound.lowerOpen);\n                            upper = self.helper.changeCase(angular.copy(model.bound.upper), false, true);\n                            incUpper = (model.bound.upperOpen === undefined) ? false : angular.copy(model.bound.upperOpen);\n\n                            //if lower bound is undefined then setting only upper bound\n                            if (model.bound.lower === undefined) {\n                                model.bound = self.keyRange.upperBound(upper, incUpper);\n\n                            } else if (model.bound.upper === undefined) {\n                                //if upper bound is undefined then setting only upper bound\n                                model.bound = self.keyRange.lowerBound(lower, incLower);\n\n                            } else {\n                                //else setting both bound values\n                                model.bound = self.keyRange.bound(lower, upper, incLower, incUpper);\n                            }\n\n                        }\n                    }\n\n                    return model;\n                };\n\n                //between function(not case sensitive)\n                model.between = function (lower, upper, incLower, incUpper) {\n                    incLower = (incLower !== undefined) ? false : incLower;\n                    incUpper = (incUpper !== undefined) ? false : incUpper;\n\n                    //checking if work to do is caseInsensitive\n                    if (model.caseInsensitive) {\n                        lower = self.helper.changeCase(lower, true, true);\n                        upper = self.helper.changeCase(upper, false, true);\n                    }\n\n                    model.bound = self.keyRange.bound(lower, upper, incLower, incUpper);\n                    return model;\n                };\n\n                //where in model function for setting whereInValues\n                model.whereIn = function (inValues, sortAsNumbers) {\n\n                    sortAsNumbers = (sortAsNumbers === true) ? true : false;\n                    model.whereInValues = inValues;\n\n                    model.isWhereNumber = sortAsNumbers; //setting whereIn as number type\n\n                    if (model.caseInsensitive) {\n                        model.whereInValues = self.helper.setOrderSettings(model.whereInValues, sortAsNumbers, model.isDesc);\n                    }\n\n                    return model;\n                };\n\n                //function sets where not in values for model\n                model.whereNotIn = function (notInValues, sortAsNumbers) {\n\n                    sortAsNumbers = (sortAsNumbers === true) ? true : false;\n                    model.whereNotInValues = notInValues;\n\n                    model.isWhereNumber = sortAsNumbers; //setting whereNotInValues as number type\n\n                    if (model.caseInsensitive) {\n                        model.whereNotInValues = self.helper.setOrderSettings(model.whereNotInValues, sortAsNumbers, model.isDesc);\n                    }\n\n                    return model;\n                };\n\n                //functions sets the filter for traversing\n                model.filter = function (filterFunction) {\n                    model.hasFilter = true;\n                    if (typeof filterFunction !== 'function') {\n                        throw \"A function must be given as parameter for filter\";\n                    }\n                    model.filterFunction = filterFunction;\n                    return model;\n                };\n\n                //function sets the like string search setting\n                model.like = function (likeString) {\n                    if (likeString === undefined) {\n                        throw \"Invalid input given to like\";\n                    }\n\n                    model.likeString = likeString.toString();\n                    return model;\n                };\n\n                //query builder for with relations\n                model.withRelations = function (relations) {\n                    if (typeof relations !== 'object') {\n                        throw \"WithRelation must be at type of object\";\n                    }\n\n                    model.hasWith = true;\n                    model.originalWithRelation = relations; //keeping a record of original relation data\n                    model.withRelation = _setWithRelation(relations); //setting objects for using with relations\n\n                    return model;\n                };\n\n            }\n\n            /**\n             * Class : Definition for aggregation builder\n             * @param {object} table [table/Object store of model]\n             */\n            function CreateAggregateBuilder(table) {\n                CreateModelBuilder.call(this, table);\n                var aggregate = this;\n\n                //function sets the default state of aggregate builder\n                function _defaultModelSettings() {\n                    aggregate.sums = [];\n                    aggregate.mins = [];\n                    aggregate.maxs = [];\n                    aggregate.averages = [];\n                    aggregate.customs = [];\n                }\n\n                _defaultModelSettings();\n\n                //function registers a sum aggregate against the property\n                aggregate.sum = function (property) {\n\n                    if (property === undefined) {\n                        property = (aggregate.index === null) ? table.fields.keyPathField : aggregate.index;\n                    }\n\n                    if (aggregate.sums.indexOf(property) === -1) {\n                        aggregate.sums.push(property);\n                    }\n\n                    return aggregate;\n                };\n\n                //function registers a min aggregate against the property\n                aggregate.min = function (property) {\n\n                    if (property === undefined) {\n                        property = (aggregate.index === null) ? table.fields.keyPathField : aggregate.index;\n                    }\n\n                    if (aggregate.mins.indexOf(property) === -1) {\n                        aggregate.mins.push(property);\n                    }\n\n\n                    return aggregate;\n                };\n\n                //function registers a max aggregate against the property\n                aggregate.max = function (property) {\n\n                    if (property === undefined) {\n                        property = (aggregate.index === null) ? table.fields.keyPathField : aggregate.index;\n                    }\n\n                    if (aggregate.maxs.indexOf(property) === -1) {\n                        aggregate.maxs.push(property);\n                    }\n\n                    return aggregate;\n                };\n\n                //function registers a average aggregate against the property\n                aggregate.average = function (property) {\n\n                    if (property === undefined) {\n                        property = (aggregate.index === null) ? table.fields.keyPathField : aggregate.index;\n                    }\n\n                    if (aggregate.averages.indexOf(property) === -1) {\n                        aggregate.averages.push(property);\n                    }\n\n                    return aggregate;\n                };\n\n                //function registers a custom aggregate against the property\n                aggregate.custom = function (name, callback, endCallback) {\n\n                    //checking various parameters before continuing\n                    if (typeof name !== 'string') {\n                        throw \"Custom aggregate first parameter must be a string\";\n                    }\n\n                    if (typeof callback !== 'function') {\n                        throw \"Custom aggregate second parameter must be a function\";\n                    }\n\n                    if (endCallback !== undefined) {\n                        if (typeof endCallback !== 'function') {\n                            throw \"Custom aggregate third parameter must be a function\";\n                        }\n                    }\n\n                    var customObject = {};\n                    customObject.callback = callback;\n                    customObject.endCallback = endCallback;\n                    customObject.name = name;\n\n                    var testDuplicate = aggregate.customs.filter(function (custom) {\n                        return (custom.name === name);\n                    });\n\n                    if (testDuplicate.length !== 0) {\n                        throw \"Repeated Custom aggregate name given : \" + name;\n                    }\n\n                    aggregate.customs.push(customObject);\n\n                    return aggregate;\n                };\n            }\n\n            /**\n             * Function defines query builder for other attributes not being searched by index\n             * @param {object} table [table information]\n             */\n            function CreateOtherBuilder(table) {\n                CreateAggregateBuilder.apply(this, [table]);\n\n                var model = this;\n\n                //function sets the default state of other builder\n                function _defaultModelSettings() {\n                    model.andObject = null; //default andObject data\n                    model.orObject = null; //default orObject data\n                    model.inObject = null; //default inObject data\n                    model.notInObject = null; //default notInObject data\n                    model.likeObject = null; //default likeOther data\n                    model.gtObject = null; //default gtOther data\n                    model.gteObject = null; //default gteOther data\n                    model.ltObject = null; //default ltOther data\n                    model.lteObject = null; //default lteOther data\n                }\n\n                _defaultModelSettings();\n\n                //and query builder\n                model.whereOtherAnd = function (propertyName, propertyValue) {\n                    var andObject = {};\n                    if (typeof propertyName !== \"string\") {\n                        throw \"Invalid first argument. Property name must be a string\";\n                    }\n\n                    if (model.andObject === null) {\n                        model.andObject = [];\n                    }\n\n                    andObject.propertyName = propertyName;\n                    andObject.propertyValue = propertyValue;\n\n                    model.andObject.push(andObject);\n\n                    return model;\n                };\n\n                //or query builder\n                model.whereOtherOr = function (propertyName, propertyValue) {\n                    var orObject = {};\n                    if (typeof propertyName !== \"string\") {\n                        throw \"Invalid first argument. Property name must be a string\";\n                    }\n\n                    if (model.orObject === null) {\n                        model.orObject = [];\n                    }\n\n                    orObject.propertyName = propertyName;\n                    orObject.propertyValue = propertyValue;\n\n                    model.orObject.push(orObject);\n\n                    return model;\n                };\n\n                //where in query builder\n                model.whereOtherIn = function (propertyName, propertyValue) {\n                    var inObject = {};\n                    if (typeof propertyName !== \"string\") {\n                        throw \"Invalid first argument. Property name must be a string\";\n                    }\n\n                    if (propertyValue.constructor !== Array) {\n                        throw \"Invalid second argument. Property value must be an array\";\n                    }\n\n                    if (model.inObject === null) {\n                        model.inObject = [];\n                    }\n\n                    inObject.propertyName = propertyName;\n                    inObject.propertyValue = propertyValue;\n\n                    model.inObject.push(inObject);\n\n                    return model;\n                };\n\n                //where not in query builder\n                model.whereOtherNotIn = function (propertyName, propertyValue) {\n                    var notInObject = {};\n                    if (typeof propertyName !== \"string\") {\n                        throw \"Invalid first argument. Property name must be a string\";\n                    }\n\n                    if (propertyValue.constructor !== Array) {\n                        throw \"Invalid second argument. Property value must be an array\";\n                    }\n\n                    if (model.notInObject === null) {\n                        model.notInObject = [];\n                    }\n\n                    notInObject.propertyName = propertyName;\n                    notInObject.propertyValue = propertyValue;\n\n                    model.notInObject.push(notInObject);\n\n                    return model;\n                };\n\n                //like query builder\n                model.whereOtherLike = function (propertyName, propertyValue){\n                    var likeObject = {};\n                    if (typeof propertyName !== \"string\") {\n                        throw \"Invalid first argument. Property name must be a string\";\n                    }\n\n                    if (typeof propertyValue !== \"string\") {\n                        throw \"Invalid second argument. Property value must be an string\";\n                    }\n\n                    likeObject.propertyName = propertyName;\n                    likeObject.propertyValue = propertyValue;\n\n                    model.likeObject.push(likeObject);\n\n                    return model;\n                };\n\n                //greater then query builder\n                model.whereOtherGt = function (propertyName, propertyValue){\n                    var gtObject = {};\n                    if (typeof propertyName !== \"string\") {\n                        throw \"Invalid first argument. Property name must be a string\";\n                    }\n\n                    if (propertyValue === undefined || propertyValue === '') {\n                        throw \"Invalid second argument. Property value cannot be empty\";\n                    }\n\n                    gtObject.propertyName = propertyName;\n                    gtObject.propertyValue = propertyValue;\n\n                    model.gtObject.push(gtObject);\n\n                    return model;\n                };\n\n                //greater than equal query builder\n                model.whereOtherGte = function (propertyName, propertyValue){\n                    var gteObject = {};\n                    if (typeof propertyName !== \"string\") {\n                        throw \"Invalid first argument. Property name must be a string\";\n                    }\n\n                    if (propertyValue === undefined || propertyValue === '') {\n                        throw \"Invalid second argument. Property value cannot be empty\";\n                    }\n\n                    gteObject.propertyName = propertyName;\n                    gteObject.propertyValue = propertyValue;\n\n                    model.gteObject.push(gteObject);\n\n                    return model;\n                };\n\n                //less than equal query builder\n                model.whereOtherLte = function (propertyName, propertyValue){\n                    var lteObject = {};\n                    if (typeof propertyName !== \"string\") {\n                        throw \"Invalid first argument. Property name must be a string\";\n                    }\n\n                    if (propertyValue === undefined || propertyValue === '') {\n                        throw \"Invalid second argument. Property value cannot be empty\";\n                    }\n\n                    lteObject.propertyName = propertyName;\n                    lteObject.propertyValue = propertyValue;\n\n                    model.lteObject.push(lteObject);\n\n                    return model;\n                };\n\n                //less than query builder\n                model.whereOtherLt = function (propertyName, propertyValue){\n                    var ltObject = {};\n                    if (typeof propertyName !== \"string\") {\n                        throw \"Invalid first argument. Property name must be a string\";\n                    }\n\n                    if (propertyValue === undefined || propertyValue === '') {\n                        throw \"Invalid second argument. Property value cannot be empty\";\n                    }\n\n                    ltObject.propertyName = propertyName;\n                    ltObject.propertyValue = propertyValue;\n\n                    model.ltObject.push(ltObject);\n\n                    return model;\n                };\n            }\n            /**\n             * Class : Final builder class that fires various action in promises\n             * @param {object} table [table/object store of model]\n             */\n            function CreateModel(table) {\n                CreateOtherBuilder.apply(this, [table]);\n\n                var model = this;\n                var transaction;\n                var objectStore;\n                var withRelationObject = {};\n                var aggregateObject = {};\n\n                /**\n                 * Function checks result against various model filters\n                 * @param  {IDBCursor} result [contains the IDBCursor value against the current record]\n                 * @return {boolean}        [true if passes all]\n                 */\n                function _checkResult(result) {\n                    var i, propertyValue, andStatus, orStatus, hasAnd, property;\n                    andStatus = true;\n                    orStatus = false;\n                    hasAnd = false;\n\n                    //if model has filter\n                    if (model.hasFilter) {\n                        if (model.filterFunction(result.value) !== true) {\n                            return false;\n                        }\n                    }\n\n                    //checking for likeness in data\n                    if (model.likeString !== null) {\n                        if (self.helper.checkLikeString(result.key, model.likeString, model.caseInsensitive) === false) {\n                            return false;\n                        }\n                    }\n\n                    //first for whereIn model values then whereNotIn else default\n                    if (model.whereInValues !== null) {\n                        if (!self.helper.whereIn(result.key, model.whereInValues, model.caseInsensitive)) {\n                            return false;\n                        }\n\n                    }\n\n                    if (model.whereNotInValues !== null) {\n                        if (!self.helper.whereNotIn(result.key, model.whereNotInValues, model.caseInsensitive)) {\n                            return false;\n                        }\n\n                    }\n\n                    //checking other values as where not in conditions\n                    if (model.inObject !== null) {\n\n                        //for each condition set against the value\n                        for (i = model.inObject.length - 1; i >= 0; i--) {\n                            property = model.inObject[i];\n\n                            //fetching value at that propery in main result\n                            propertyValue = self.helper.getPropertyValue(property.propertyName, result.value);\n\n                            //if property value is undefined then returning false\n                            if (propertyValue === undefined) {\n                                return false;\n                            }\n\n                            if (!self.helper.whereIn(propertyValue, property.propertyValue, model.caseInsensitive)) {\n                                return false;\n                            }\n\n                        }\n                    }\n\n                    //checking other values as where in conditions\n                    if (model.notInObject !== null) {\n\n                        //for each condition set against the value\n                        for (i = model.notInObject.length - 1; i >= 0; i--) {\n                            property = model.notInObject[i];\n\n                            //fetching value at that propery in main result\n                            propertyValue = self.helper.getPropertyValue(property.propertyName, result.value);\n\n                            //if property value is undefined then returning false\n                            if (propertyValue === undefined) {\n                                continue;\n                            }\n\n                            if (!self.helper.whereNotIn(propertyValue, property.propertyValue, model.caseInsensitive)) {\n                                return false;\n                            }\n\n                        }\n                    }\n\n                    //checking other values as like condition\n                    if(model.likeObject !== null){\n\n                        for (i = model.likeObject.length - 1; i >= 0; i--) {\n                            property = model.likeObject[i];\n\n                            propertyValue = self.helper.getPropertyValue(property.propertyName, result.value);\n\n                            if (propertyValue === undefined) {\n                                return false;\n                            }\n\n                            if(!self.helper.checkLikeString(propertyValue, property.propertyValue, model.caseInsensitive)){\n                                return false;\n                            }\n                        }\n                    }\n\n                    //checking other values as greater than equal condition\n                    if(model.gteObject !== null){\n\n                        for (i = model.gteObject.length - 1; i >= 0; i--) {\n                            property = model.gteObject[i];\n\n                            propertyValue = self.helper.getPropertyValue(property.propertyName, result.value);\n\n                            if (propertyValue === undefined) {\n                                return false;\n                            }\n\n                            if(property.propertyValue < propertyValue){\n                                return false;\n                            }\n                        }\n                    }\n\n                    //checking other values as greater than condition\n                    if(model.gtObject !== null){\n\n                        for (i = model.gtObject.length - 1; i >= 0; i--) {\n                            property = model.gtObject[i];\n\n                            propertyValue = self.helper.getPropertyValue(property.propertyName, result.value);\n\n                            if (propertyValue === undefined) {\n                                return false;\n                            }\n\n                            if(property.propertyValue <= propertyValue){\n                                return false;\n                            }\n                        }\n                    }\n\n                    //checking other values as less than equal condition\n                    if(model.lteObject !== null){\n\n                        for (i = model.lteObject.length - 1; i >= 0; i--) {\n                            property = model.lteObject[i];\n\n                            propertyValue = self.helper.getPropertyValue(property.propertyName, result.value);\n\n                            if (propertyValue === undefined) {\n                                return false;\n                            }\n\n                            if(property.propertyValue > propertyValue){\n                                return false;\n                            }\n                        }\n                    }\n\n                    //checking other values as less than equal condition\n                    if(model.ltObject !== null){\n\n                        for (i = model.ltObject.length - 1; i >= 0; i--) {\n                            property = model.ltObject[i];\n\n                            propertyValue = self.helper.getPropertyValue(property.propertyName, result.value);\n\n                            if (propertyValue === undefined) {\n                                return false;\n                            }\n\n                            if(property.propertyValue >= propertyValue){\n                                return false;\n                            }\n                        }\n                    }\n\n                    //checking other values as and conditions\n                    if (model.andObject !== null) {\n\n                        hasAnd = true;\n\n                        for (i = model.andObject.length - 1; i >= 0; i--) {\n                            property = model.andObject[i];\n\n                            propertyValue = self.helper.getPropertyValue(property.propertyName, result.value);\n\n                            if (propertyValue === undefined || propertyValue !== property.propertyValue) {\n                                andStatus = false;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (model.orObject !== null) {\n                        orStatus = false;\n\n                        if (!hasAnd) {\n                            andStatus = false;\n                            if (model.orObject.length === 0) {\n                                return true;\n                            }\n                        }\n\n\n                        for (i = model.orObject.length - 1; i >= 0; i--) {\n                            property = model.orObject[i];\n\n                            propertyValue = self.helper.getPropertyValue(property.propertyName, result.value);\n\n                            if (propertyValue !== undefined && propertyValue === property.propertyValue) {\n                                orStatus = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!(andStatus || orStatus)) {\n                        return false;\n                    }\n\n                    return true;\n                }\n\n                //function : withRelation action to retrieve all relational data in main outcome \n                withRelationObject.getRelationData = function (outcome, isFind, propertyName) {\n                    var _id;\n                    if (isFind) {\n                        _id = angular.copy(outcome[propertyName]);\n\n                        //if _id is undefined then\n                        if (_id === undefined) {\n                            return false;\n                        }\n\n                        //_id is not an array then\n                        if (_id.constructor !== Array) {\n                            _id = [_id];\n                        }\n                        _id = _id.sort();\n\n                        return _id;\n                    }\n\n                    _id = [];\n\n                    outcome.forEach(function (value) {\n                        if (value[propertyName] !== undefined) {\n                            value[propertyName].forEach(function (propertyValue) {\n                                if (_id.indexOf(propertyValue) === -1) {\n                                    _id.push(propertyValue);\n                                }\n                            });\n                        }\n                    });\n\n                    _id = _id.sort();\n\n                    if (_id.length === 0) {\n                        return false;\n                    }\n\n                    return _id;\n\n                };\n\n                //function sets outcome value by setting with Relation property or relational table\n                //and sets checks if the relation exists in main outcome\n                withRelationObject.setOutcome = function (outcome, withTableName, propertyName, relationsData, isFind) {\n                    var tableSchema = self.tables.filter(function (tableObject) {\n                        return (tableObject.name === withTableName);\n                    })[0];\n\n                    if (isFind) {\n                        outcome.Relations = outcome.Relations || {};\n                        outcome.Relations[withTableName] = [];\n                        relationsData.forEach(function (relationData) {\n                            if (outcome[propertyName].indexOf(relationData[tableSchema.fields.keyPathField]) > 0) {\n                                outcome.Relations[withTableName].push(relationData);\n                            }\n                        });\n                        return outcome;\n                    }\n\n                    outcome.forEach(function (outcomeData) {\n                        outcomeData.Relations = outcomeData.Relations || {};\n                        outcomeData.Relations[withTableName] = [];\n\n                        relationsData.forEach(function (relationData) {\n\n                            if (outcomeData[propertyName] === undefined) {\n                                return false;\n                            }\n\n                            if (outcomeData[propertyName].indexOf(relationData[tableSchema.fields.keyPathField]) >= 0) {\n                                outcomeData.Relations[withTableName].push(relationData);\n                            }\n                        });\n                    });\n                    return outcome;\n                };\n\n                /**\n                 * private : function calls relation tables and fetches their data\n                 * @param  {[type]}  resolve           [description]\n                 * @param  {[type]}  reject            [description]\n                 * @param  {array/object}  outcome           [contains main table record(s)]\n                 * @param  {object}  objectStoreTables [with tables in transaction mode]\n                 * @param  {Boolean} isFind            [true for find condition]\n                 */\n                withRelationObject.getWithAllData = function (resolve, reject, outcome, objectStoreTables, isFind) {\n                    //setting default value for isFind\n                    isFind = (isFind === undefined) ? false : isFind;\n\n                    var withTablesCount, relationNames;\n\n                    relationNames = Object.keys(objectStoreTables); //getting relational table names\n                    withTablesCount = relationNames.length;\n\n                    var currentCount = 0;\n\n                    //for each relational table\n                    relationNames.forEach(function (withTableName) {\n                        var _id;\n                        //retrieving relation values from main table\n                        _id = withRelationObject.getRelationData(outcome, isFind, model.originalWithRelation[withTableName].field);\n\n                        //if main table has no relation values then setting Relation status that relational table as empty array\n                        if (_id === false) {\n                            outcome = withRelationObject.setOutcome(outcome, withTableName, model.originalWithRelation[withTableName].field, [], isFind);\n                            currentCount = currentCount + 1;\n\n                            if (currentCount === withTablesCount) {\n                                resolve(outcome);\n                            }\n                            return false;\n                        }\n\n                        var currentOutcome = [];\n                        var hasFilter = false;\n\n                        //if filter was set in relation then setting hasFilter flag\n                        if (typeof model.originalWithRelation[withTableName].filter === 'function') {\n                            hasFilter = true;\n                        }\n\n                        //opening relational table and fetching data\n                        objectStoreTables[withTableName].openCursor(self.keyRange.bound(_id[0], _id[(_id.length - 1)])).onsuccess = function (event) {\n                            try {\n\n                                var cursor = event.target.result;\n                                if (cursor) {\n\n                                    //if relation has filter\n                                    if (hasFilter) {\n                                        if (model.originalWithRelation[withTableName].filter(cursor.value) !== true) {\n                                            cursor.continue();\n                                            return false;\n                                        }\n                                    }\n\n                                    if (!self.helper.whereIn(cursor.key, _id, false)) {\n                                        cursor.continue();\n                                        return false;\n                                    }\n\n                                    currentOutcome.push(cursor.value);\n                                    cursor.continue();\n\n                                } else {\n                                    //when traversing is done\n                                    outcome = withRelationObject.setOutcome(outcome, withTableName, model.originalWithRelation[withTableName].field, currentOutcome, isFind);\n\n                                    currentCount = currentCount + 1;\n\n                                    //when all of the relation tables have completed traversing then resolving\n                                    if (currentCount === withTablesCount) {\n                                        resolve(outcome);\n                                    }\n                                }\n                            } catch (exception) {\n                                transaction.abort();\n                                reject(exception);\n                            }\n                        };\n\n                        //case or error of in relation object store\n                        objectStoreTables[withTableName].openCursor(self.keyRange.bound(_id[0], _id[(_id.length - 1)])).onerror = function (e) {\n                            transaction.abort();\n                            reject(e);\n                        };\n                    });\n\n                };\n\n                //function : calculates aggregate of sum against all sum set\n                aggregateObject.getSums = function (outcome, result) {\n                    if (model.sums.length === 0) {\n                        return outcome;\n                    }\n\n                    outcome.sums = outcome.sums || {};\n\n                    model.sums.forEach(function (property) {\n                        outcome.sums[property] = (outcome.sums[property] === undefined) ? 0 : outcome.sums[property];\n                        var value = self.helper.getPropertyValue(property, result);\n                        if (typeof value === 'number') {\n                            outcome.sums[property] = outcome.sums[property] + value;\n                        }\n                    });\n\n                    return outcome;\n                };\n\n                //function : calculates aggregate of min against all min set\n                aggregateObject.getMins = function (outcome, result) {\n                    if (model.mins.length === 0) {\n                        return outcome;\n                    }\n\n                    outcome.mins = outcome.mins || {};\n\n                    model.mins.forEach(function (property) {\n                        var value = self.helper.getPropertyValue(property, result);\n\n                        if (value === undefined) {\n                            return false;\n                        }\n\n                        outcome.mins[property] = (outcome.mins[property] === undefined) ? value : outcome.mins[property];\n\n                        outcome.mins[property] = self.helper.minValue(outcome.mins[property], value);\n                    });\n\n                    return outcome;\n                };\n\n                //function : calculates aggregate of max against all max set\n                aggregateObject.getMaxs = function (outcome, result) {\n                    if (model.mins.length === 0) {\n                        return outcome;\n                    }\n\n                    outcome.maxs = outcome.maxs || {};\n\n                    model.maxs.forEach(function (property) {\n                        var value = self.helper.getPropertyValue(property, result);\n\n                        if (value === undefined) {\n                            return false;\n                        }\n\n                        outcome.maxs[property] = (outcome.maxs[property] === undefined) ? value : outcome.maxs[property];\n\n                        outcome.maxs[property] = self.helper.maxValue(outcome.maxs[property], value);\n                    });\n\n                    return outcome;\n                };\n\n                //function : calculates aggregate of averages against all averages set\n                aggregateObject.getAverages = function (outcome, resultOrCount, finalCalculation) {\n                    if (model.averages.length === 0) {\n                        return outcome;\n                    }\n\n                    outcome.averages = outcome.averages || {};\n\n                    model.averages.forEach(function (property) {\n                        if (finalCalculation === true) {\n                            outcome.averages[property] = outcome.averages[property] / resultOrCount;\n                            return false;\n                        }\n\n                        outcome.averages[property] = (outcome.averages[property] === undefined) ? 0 : outcome.averages[property];\n\n                        var value = self.helper.getPropertyValue(property, resultOrCount);\n\n                        if (typeof value === 'number') {\n                            outcome.averages[property] = outcome.averages[property] + value;\n                        }\n                    });\n\n                    return outcome;\n                };\n\n                //function : calculates aggregate of custom functions against all custom functions set\n                aggregateObject.getCustoms = function (outcome, resultOrCount, finalCalculation) {\n                    if (model.customs.length === 0) {\n                        return outcome;\n                    }\n\n                    outcome.customs = outcome.customs || {};\n\n                    model.customs.forEach(function (customObject) {\n                        if (finalCalculation === true && customObject.endCallback !== undefined) {\n                            outcome.customs[customObject.name] = customObject.endCallback(outcome[customObject.name], resultOrCount);\n                            return false;\n                        }\n\n                        outcome.customs[customObject.name] = (outcome.customs[customObject.name] === undefined) ? 0 : outcome.customs[customObject.name];\n\n                        var value = self.helper.getPropertyValue(customObject.name, resultOrCount);\n\n                        outcome.customs[customObject.name] = customObject.callback(outcome.customs[customObject.name], value);\n                    });\n\n                    return outcome;\n                };\n\n                //private : function returns array of table names to perform transaction on\n                function _getTransactionTables() {\n                    var transactionTables = [];\n                    //default pushing main table name\n                    transactionTables.push(table.name);\n\n                    if (model.hasWith) {\n                        //pushing relation table names\n                        var withTables = Object.keys(model.withTables);\n                        withTables.forEach(function (withTable) {\n                            transactionTables.push(withTable);\n                        });\n\n                    }\n\n                    return transactionTables;\n                }\n\n                //private : wrapper for calling default getAll with callback for success\n                function _get(callback, readwrite) {\n                    //setting read write status flag of transaction\n                    var write = (readwrite === undefined || readwrite === false || readwrite === null) ? 'readonly' : 'readwrite';\n\n                    var transactionTables = [];\n                    var relations = {};\n\n                    return $q(function (resolve, reject) {\n                        self.openConnection.then(function (event) {\n                            try {\n                                var db = event.target.result;\n                                //opening transaction\n                                transactionTables = _getTransactionTables();\n                                transaction = db.transaction(transactionTables, write);\n\n                                //if model has with relation\n                                if (model.hasWith) {\n                                    transactionTables.splice(0, 1);\n                                    transactionTables.forEach(function (tableName) {\n                                        relations[tableName] = transaction.objectStore(tableName);\n                                    });\n\n                                }\n\n                                objectStore = transaction.objectStore(table.name);\n\n                                //if index is defined then adding index to object store\n                                if (model.index !== null) {\n                                    objectStore = objectStore.index(model.index);\n                                }\n\n                                objectStore = objectStore.openCursor(model.bound, model.traverse);\n\n                                //on success giving callback with promise and relation data\n                                objectStore.onsuccess = function (event) {\n                                    try {\n                                        callback(event, resolve, reject, relations);\n\n                                    } catch (exception) {\n                                        transaction.abort();\n                                        reject(exception);\n                                    }\n                                };\n\n                                objectStore.onerror = function (error) {\n                                    transaction.abort();\n                                    reject(error);\n                                };\n\n                                transaction.onerror = function (error) {\n                                    reject(error);\n                                };\n\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n                        }).catch(function (error) {\n                            reject(error);\n                        });\n                    });\n                }\n\n                //private : function returns new object value to be updated with timestamps\n                function _updateValue(result, data, hasTimeStamp) {\n                    hasTimeStamp = (hasTimeStamp === undefined) ? false : hasTimeStamp;\n\n                    var newValue = angular.copy(result);\n\n                    var properties = Object.keys(data);\n                    properties.forEach(function (property) {\n                        newValue[property] = data[property];\n                    });\n\n                    if (table.hasTimeStamp && !hasTimeStamp) {\n                        newValue.updatedAt = Date.parse(Date());\n                    }\n\n                    if (hasTimeStamp) {\n                        newValue.updatedAt = Date.parse(Date());\n                    }\n\n                    return newValue;\n                }\n\n                //private : function updates the relations indexes by adding new values\n                withRelationObject.update = function (record, data) {\n                    //retrieving properties to be updated\n                    var properties = Object.keys(data);\n\n                    properties.forEach(function (property) {\n                        //if property in main record is undefined\n                        if (record[property] === undefined) {\n                            record[property] = [];\n                        }\n                        data[property].forEach(function (relation) {\n                            //checking if relation already exists if not then adding\n\n                            //if relation is greater than or equal to zero then adding the relation\n                            if (relation >= 0) {\n                                if (record[property].indexOf(relation) === -1) {\n                                    record[property].push(relation);\n                                }\n                            } else {\n                                //else removing relation\n                                var index = record[property].indexOf(relation * (-1));\n                                if (index !== -1) {\n                                    record[property].splice(index, 1);\n                                }\n                            }\n                        });\n                    });\n\n                    return record;\n                };\n\n                /**\n                 * private : function adds relation id to related tables. If many relation is set then also adds the relation tables record ids to the main table for creating many to many\n                 * @param {resolve} resolve           [resolves the promise]\n                 * @param {reject} reject            [rejects the promise]\n                 * @param {integer} outcome           [contains newly created records key path value]\n                 * @param {object} objectStoreTables [with tables in transaction mode]\n                 * @param {IDBTransaction} transaction       [transaction instance]\n                 */\n                withRelationObject.add = function (resolve, reject, outcome, objectStoreTables, transaction) {\n                    var withTablesCount, relationNames;\n\n                    relationNames = Object.keys(objectStoreTables); //getting relational table names\n                    withTablesCount = relationNames.length;\n\n                    var currentCount = 0;\n                    var manyOutcome = {};\n\n                    relationNames.forEach(function (withTableName) {\n                        var hasFilter = false; //setting if with table has filter\n                        var isMany = false; //if main table is in many to many relationship\n                        var many = [];\n\n                        //if filter was set in relation then setting hasFilter flag\n                        if (typeof model.originalWithRelation[withTableName].filter === 'function') {\n                            hasFilter = true;\n                        }\n\n                        //setting flag for many to many\n                        if (typeof model.originalWithRelation[withTableName].many === 'object') {\n                            if (model.originalWithRelation[withTableName].many.isMany === true) {\n                                isMany = true;\n                            }\n                        }\n\n                        //opening cursor on relation table\n                        objectStoreTables[withTableName].openCursor().onsuccess = function (event) {\n                            var cursor = event.target.result;\n\n                            if (cursor) {\n                                var newValue = _updateValue(cursor.value, {}, true);\n\n                                //if relation has filter\n                                if (hasFilter) {\n                                    if (model.originalWithRelation[withTableName].filter(angular.copy(cursor.value)) !== true) {\n                                        cursor.continue();\n                                        return;\n                                    }\n                                }\n\n                                //if property of relation is undefined then creating one as an array\n                                if (newValue[model.originalWithRelation[withTableName].field] === undefined) {\n                                    newValue[model.originalWithRelation[withTableName].field] = [];\n                                }\n\n                                //if relation does not have the index then adding it to list\n                                if (newValue[model.originalWithRelation[withTableName].field].indexOf(outcome._id) === -1) {\n                                    newValue[model.originalWithRelation[withTableName].field].push(outcome._id);\n\n                                    //case for many to many\n                                    if (isMany) {\n                                        many.push(cursor.value._id);\n                                    }\n                                }\n\n                                cursor.update(newValue);\n                                cursor.continue();\n\n                            } else {\n                                currentCount = currentCount + 1;\n\n                                //case for may then adding many relation to newly created object\n                                if (isMany === true) {\n                                    manyOutcome[model.originalWithRelation[withTableName].many.field] = many;\n                                }\n\n                                if (currentCount === withTablesCount) {\n\n                                    //if is many relationship then also updating current outcome value\n                                    if (isMany) {\n                                        outcome = _updateValue(outcome, manyOutcome);\n\n                                        var newObjectStore = transaction.objectStore(table.name);\n\n                                        newObjectStore.put(outcome).onsuccess = function () {\n                                            resolve(outcome);\n                                        };\n\n                                        newObjectStore.onerror = function (error) {\n                                            transaction.abort();\n                                            reject(error);\n                                        };\n\n                                    } else {\n                                        resolve(outcome);\n                                    }\n                                }\n                            }\n                        };\n\n                        objectStoreTables[withTableName].openCursor().onerror = function (error) {\n                            transaction.abort();\n                            reject(error);\n                        };\n                    });\n                };\n\n                /**\n                 * private : function delete the record relation to other tables\n                 * @param  {resolve}  resolve           [resolves the promise]\n                 * @param  {reject}  reject            [reject the promise]\n                 * @param  {array/integer}  value             [contains the id(s) of records delete]\n                 * @param  {object}  objectStoreTables [with tables in transaction mode]\n                 * @param  {Boolean} isDestroy         [for destroy mode]\n                 */\n                withRelationObject.destroy = function (resolve, reject, value, objectStoreTables, isDestroy, count) {\n                    isDestroy = (isDestroy === undefined) ? false : isDestroy;\n                    var withTablesCount, relationNames;\n\n                    relationNames = Object.keys(objectStoreTables); //getting relational table names\n                    withTablesCount = relationNames.length;\n\n                    var currentCount = 0;\n                    var bound;\n\n                    //setting bound values for cursor location\n                    if (isDestroy) {\n                        value = value.sort();\n                        bound = self.keyRange.bound(value[0], value[(value.length - 1)]);\n                    } else {\n                        bound = self.keyRange.only(value);\n                    }\n\n                    relationNames.forEach(function (withTableName) {\n                        objectStoreTables[withTableName].index(model.originalWithRelation[withTableName].field).openCursor(bound).onsuccess = function (event) {\n                            try {\n                                var cursor = event.target.result;\n                                if (cursor) {\n                                    var newValue = _updateValue(cursor.value, {}, true);\n                                    if (newValue[model.originalWithRelation[withTableName].field] === undefined) {\n                                        cursor.continue();\n                                        return;\n                                    }\n\n                                    var index;\n                                    if (isDestroy) {\n                                        value.forEach(function (_id) {\n                                            index = newValue[model.originalWithRelation[withTableName].field].indexOf(_id);\n\n                                            if (index !== -1) {\n                                                newValue[model.originalWithRelation[withTableName].field].splice(index, 1);\n                                            }\n                                        });\n                                    } else {\n                                        index = newValue[model.originalWithRelation[withTableName].field].indexOf(value);\n\n                                        if (index === -1) {\n                                            cursor.continue();\n                                            return;\n                                        }\n\n                                        newValue[model.originalWithRelation[withTableName].field].splice(index, 1);\n                                    }\n\n\n                                    cursor.update(newValue);\n                                    cursor.continue();\n\n                                } else {\n\n                                    currentCount = currentCount + 1;\n\n                                    if (currentCount === withTablesCount) {\n                                        resolve(count);\n                                    }\n                                }\n                            } catch (exception) {\n                                transaction.abort();\n                                reject(exception);\n                            }\n\n                        };\n\n                        objectStoreTables[withTableName].onerror = function (error) {\n                            transaction.abort();\n                            reject(error);\n                        };\n                    });\n                };\n\n                //finds a single record according to value set (not case sensitive)\n                model.find = function () {\n\n                    var getId = $q(function (resolve, reject) {\n                        self.openConnection.then(function (event) {\n                            var transactionTables = [];\n                            var relations = {};\n\n                            try {\n                                var db = event.target.result;\n\n                                transactionTables = _getTransactionTables();\n                                transaction = db.transaction(transactionTables);\n\n                                if (model.hasWith) {\n                                    transactionTables.splice(0, 1);\n                                    transactionTables.forEach(function (withTableName) {\n                                        relations[withTableName] = transaction.objectStore(withTableName);\n                                    });\n                                }\n\n                                objectStore = transaction.objectStore(table.name);\n\n                                //if index is set then searching on the index\n                                if (model.index !== null) {\n                                    objectStore = objectStore.index(model.index);\n                                }\n\n                                objectStore = objectStore.get(model.bound);\n                                objectStore.onsuccess = function (record) {\n                                    try {\n                                        //if no record was found then resolving\n                                        if (record === undefined) {\n                                            resolve(record);\n                                            return false;\n                                        }\n\n                                        //if with relationship was defined then\n                                        if (model.hasWith) {\n                                            withRelationObject.getWithAllData(resolve, reject, record.target.result, relations, true);\n                                            return false;\n                                        }\n\n                                        resolve(record.target.result);\n\n                                    } catch (exception) {\n                                        transaction.abort();\n                                        reject(exception);\n                                    }\n                                };\n\n                                objectStore.onerror = function (error) {\n                                    transaction.abort();\n                                    reject(error);\n                                };\n\n                                transaction.onerror = function (error) {\n                                    reject(error);\n                                };\n\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n\n                        }).catch(function (error) {\n                            reject(error);\n                        });\n\n                    });\n\n                    return getId;\n                };\n\n                //function adds single record\n                model.add = function (data) {\n\n                    var add = $q(function (resolve, reject) {\n                        self.openConnection.then(function (event) {\n\n                            var transactionTables = [];\n                            var relations = {};\n\n                            try {\n                                var db = event.target.result;\n\n                                transactionTables = _getTransactionTables();\n                                transaction = db.transaction(transactionTables, \"readwrite\");\n\n                                if (model.hasWith) {\n                                    transactionTables.splice(0, 1);\n                                    transactionTables.forEach(function (withTableName) {\n                                        relations[withTableName] = transaction.objectStore(withTableName);\n                                    });\n                                }\n\n                                objectStore = transaction.objectStore(table.name);\n                                if (table.hasTimeStamp) {\n                                    data.updatedAt = Date.parse(Date());\n                                    data.createdAt = Date.parse(Date());\n                                }\n                                objectStore = objectStore.add(data);\n\n                                objectStore.onsuccess = function (event) {\n                                    try {\n                                        var result;\n                                        result = data;\n\n                                        //adding key path value to the data object after adding\n                                        result[table.fields.keyPathField] = event.target.result;\n\n                                        if (model.hasWith) {\n                                            withRelationObject.add(resolve, reject, result, relations, transaction);\n                                        } else {\n                                            resolve(result);\n\n                                        }\n\n                                    } catch (exception) {\n                                        transaction.abort();\n                                        reject(exception);\n                                    }\n\n                                };\n\n                                objectStore.onerror = function (error) {\n                                    transaction.abort();\n                                    reject(error);\n                                };\n\n                                transaction.onerror = function (event) {\n                                    reject(event.srcElement.error);\n                                };\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n                        }).catch(function (error) {\n                            reject(error);\n                        });\n                    });\n\n                    return add;\n                };\n\n                //add multiple data at once in single transaction\n                model.addMultiple = function (data) {\n                    var outcome = [];\n                    var count = data.length; //total no of records to be inserted\n                    var inserted = 0; //no of records inserted\n\n                    var add = $q(function (resolve, reject) {\n\n                        self.openConnection.then(function (event) {\n                            try {\n\n                                var db = event.target.result;\n                                transaction = db.transaction([table.name], \"readwrite\");\n\n                                try {\n\n                                    objectStore = transaction.objectStore(table.name);\n                                    //for each record\n                                    data.forEach(function (toAddData) {\n\n                                        //adding time stamps if allowed\n                                        if (table.hasTimeStamp) {\n                                            toAddData.updatedAt = Date.parse(Date());\n                                            toAddData.createdAt = Date.parse(Date());\n                                        }\n\n                                        //single add instance\n                                        objectStore.add(toAddData).onsuccess = function (event) {\n                                            try {\n                                                var result;\n                                                result = data[inserted];\n\n                                                //adding newly inserted key path value to the object\n                                                result[table.fields.keyPathField] = event.target.result;\n\n                                                outcome.push(result);\n                                                inserted = inserted + 1;\n\n                                                //if inserted count is equal to total no of records then resolving\n                                                if (inserted === count) {\n                                                    resolve(outcome);\n                                                }\n                                            } catch (exception) {\n                                                transaction.abort();\n                                                reject(exception);\n                                            }\n\n                                        };\n                                    });\n\n                                } catch (exception) {\n                                    transaction.abort();\n                                    reject(exception);\n                                    return;\n                                }\n\n\n                                transaction.onerror = function (event) {\n                                    reject(event.srcElement.error);\n                                };\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n                        }).catch(function (error) {\n                            reject(error);\n                        });\n\n                    });\n\n                    return add;\n                };\n\n                //function is default getAll function retrieves all data\n                model.getAll = function () {\n                    var outcome = [];\n\n                    var getId = _get(function (event, resolve, reject, withTables) {\n\n                        var result = event.target.result;\n\n                        if (result) {\n                            if (!_checkResult(result)) {\n                                result.continue();\n                                return false;\n                            }\n\n                            outcome.push(result.value);\n                            result.continue();\n\n\n                        } else {\n                            if (outcome.length === 0) {\n                                resolve(outcome);\n                                return false;\n                            }\n\n                            //if model has relations then resolving when relation transactions are complete else resolving\n                            if (model.hasWith) {\n                                withRelationObject.getWithAllData(resolve, reject, outcome, withTables);\n                                return false;\n                            }\n\n                            resolve(outcome);\n\n                        }\n                    });\n                    return getId;\n                };\n\n                //wrapper function firing default put on the indexed db\n                model.put = function (data) {\n                    var put = $q(function (resolve, reject) {\n                        self.openConnection.then(function (event) {\n                            try {\n                                var db = event.target.result;\n                                transaction = db.transaction([table.name], \"readwrite\");\n                                objectStore = transaction.objectStore(table.name);\n\n                                if (table.hasTimeStamp) {\n                                    data.updatedAt = Date.parse(Date());\n\n                                    if (data.createdAt === undefined) {\n                                        data.createdAt = Date.parse(Date());\n                                    }\n                                }\n\n                                if (data[table.fields.keyPathField] === undefined) {\n                                    transaction.abort();\n                                    reject(new Error(\"KeyPath field not provied for update\"));\n                                }\n\n                                //firing put method\n                                objectStore = objectStore.put(data);\n\n                                objectStore.onsuccess = function (event) {\n                                    try {\n                                        //adding newly/existing key path value to the object\n                                        data[table.keyPathField] = event.target.result;\n                                        resolve(data);\n\n                                    } catch (exception) {\n                                        transaction.abort();\n                                        reject(exception);\n                                    }\n                                };\n\n                                objectStore.onerror = function (error) {\n                                    transaction.abort();\n                                    reject(error);\n                                };\n\n                                transaction.onerror = function (error) {\n                                    reject(error);\n                                };\n\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n                        }).catch(function (error) {\n                            reject(error);\n                        });\n\n                    });\n\n                    return put;\n                };\n\n                //function fires update method on the model\n                model.update = function (data) {\n                    if (typeof data !== 'object') {\n                        throw \"Data must be type of object\";\n                    }\n\n                    var count = 0;\n                    var update = _get(function (event, resolve) {\n                        var result = event.target.result;\n                        var newValue;\n\n                        if (result) {\n\n\n                            if (!_checkResult(result)) {\n                                result.continue();\n                                return false;\n                            }\n\n                            newValue = _updateValue(result.value, data);\n\n                            //setting with relation data to the record as well\n                            if (model.hasWith) {\n                                newValue = withRelationObject.update(newValue, model.originalWithRelation);\n                            }\n\n                            result.update(newValue);\n                            count = count + 1;\n                            result.continue();\n\n\n                        } else {\n                            resolve(count);\n                        }\n                    }, true);\n\n                    return update;\n                };\n\n                //wrapper for default delete in indexeddb\n                model.delete = function (value) {\n\n                    if (value === undefined) {\n                        throw \"Empty value provided for deleting\";\n                    }\n                    var objectStoreDelete;\n                    var deleteId = $q(function (resolve, reject) {\n                        self.openConnection.then(function (event) {\n                            try {\n\n                                var db = event.target.result;\n                                var relations = {};\n\n                                var transactionTables = _getTransactionTables();\n                                transaction = db.transaction(transactionTables, 'readwrite');\n\n                                if (model.hasWith) {\n                                    transactionTables.splice(0, 1);\n                                    transactionTables.forEach(function (withTableName) {\n                                        relations[withTableName] = transaction.objectStore(withTableName);\n                                    });\n                                }\n\n                                objectStore = transaction.objectStore(table.name);\n                                objectStoreDelete = transaction.objectStore(table.name);\n\n                                objectStore.get(value).onsuccess = function (record) {\n                                    if (record.target.result === undefined) {\n                                        resolve(0);\n                                        return false;\n                                    }\n                                    objectStoreDelete = objectStoreDelete.delete(value);\n\n                                    objectStoreDelete.onsuccess = function () {\n                                        try {\n                                            if (model.hasWith) {\n                                                withRelationObject.destroy(resolve, reject, value, relations, 1);\n                                            } else {\n                                                resolve(1);\n                                            }\n                                        } catch (exception) {\n                                            transaction.abort();\n                                            reject(exception);\n                                        }\n\n                                    };\n\n                                    objectStoreDelete.onerror = function (error) {\n                                        transaction.abort();\n                                        reject(error);\n                                    };\n                                };\n\n\n                                transaction.onerror = function (error) {\n                                    reject(error);\n                                };\n\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n                        }).catch(function (error) {\n                            reject(error);\n                        });\n                    });\n\n                    return deleteId;\n                };\n\n                //function to delete on cursor location\n                model.destroy = function () {\n                    var count = 0;\n                    var deletedIds = [];\n\n                    var del = _get(function (event, resolve, reject, relations) {\n                        var result = event.target.result;\n\n                        if (result) {\n                            if (!_checkResult(result)) {\n                                result.continue();\n                                return false;\n                            }\n\n                            deletedIds.push(result.value[table.fields.keyPathField]);\n                            result.delete();\n\n                            count = count + 1;\n                            result.continue();\n\n                        } else {\n\n                            if (model.hasWith) {\n                                withRelationObject.destroy(resolve, reject, deletedIds, relations, true, count);\n                            } else {\n                                resolve(count);\n                            }\n                        }\n                    }, true);\n\n                    return del;\n                };\n\n\n\n                /**\n                 * Class : Function contains definition for aggregation\n                 */\n                function CreateAggregate() {\n                    var aggregate = this;\n\n                    //function counts the number of records\n                    aggregate.count = function () {\n                        var count = 0;\n\n                        var c = _get(function (event, resolve) {\n                            var result = event.target.result;\n\n                            //if record exists\n                            if (result) {\n\n                                //passing result through filter\n                                if (!_checkResult(result)) {\n                                    result.continue();\n                                    return false;\n                                }\n\n                                count = count + 1;\n                                result.continue();\n                            } else {\n                                resolve(count);\n                            }\n\n                        });\n\n                        return c;\n                    };\n\n                    //function calculates sum of records against the property if its value is numeric\n                    aggregate.sum = function (property) {\n                        var value;\n                        var sum = 0;\n\n                        //if property is undefined then taking model index or the keyPath field\n                        if (property === undefined) {\n                            property = (model.index === null) ? table.fields.keyPathField : model.index;\n                        }\n\n                        var c = _get(function (event, resolve) {\n                            var result = event.target.result;\n\n                            //if record exists\n                            if (result) {\n\n                                //passing result through filter\n                                if (!_checkResult(result)) {\n                                    result.continue();\n                                    return false;\n                                }\n\n                                //getting the value at the property\n                                value = self.helper.getPropertyValue(property, result.value);\n\n                                if (typeof value === 'number') {\n                                    sum = sum + value;\n                                }\n                                result.continue();\n\n                            } else {\n                                resolve(sum);\n                            }\n\n                        });\n\n                        return c;\n                    };\n\n                    //function retrieves the max value at the property\n                    aggregate.max = function (property) {\n                        var value;\n                        var max = null;\n\n                        //if property is undefined then taking model index or the keyPath field\n                        if (property === undefined) {\n                            property = (model.index === null) ? table.fields.keyPathField : model.index;\n                        }\n\n                        var m = _get(function (event, resolve) {\n                            var result = event.target.result;\n\n                            //if record exists\n                            if (result) {\n\n                                //passing result through filter\n                                if (!_checkResult(result)) {\n                                    result.continue();\n                                    return false;\n                                }\n\n                                value = self.helper.getPropertyValue(property, result.value);\n\n                                //if pointer is at first record then setting the value of max as that else checking\n                                if (value !== undefined) {\n                                    max = (max === null) ? value : self.helper.maxValue(max, value);\n                                }\n                                result.continue();\n\n                            } else {\n                                resolve(max);\n                            }\n\n                        });\n\n                        return m;\n                    };\n\n                    //function calculates the min value of property\n                    aggregate.min = function (property) {\n                        var value;\n                        var min = null;\n\n                        //if property is undefined then taking model index or the keyPath field\n                        if (property === undefined) {\n                            property = (model.index === null) ? table.fields.keyPathField : model.index;\n                        }\n\n                        var m = _get(function (event, resolve) {\n                            var result = event.target.result;\n\n                            //if record exists\n                            if (result) {\n\n                                //passing result through filter\n                                if (!_checkResult(result)) {\n                                    result.continue();\n                                    return false;\n                                }\n\n                                value = self.helper.getPropertyValue(property, result.value);\n\n                                //if pointer is at first record then setting the value of min as that else checking\n                                if (value !== undefined) {\n                                    min = (min === null) ? value : self.helper.minValue(min, value);\n                                }\n                                result.continue();\n\n                            } else {\n                                resolve(min);\n                            }\n\n                        });\n\n                        return m;\n                    };\n\n                    aggregate.average = function (property) {\n                        var value;\n                        var average = 0,\n                            sum = 0,\n                            count = 0;\n\n                        if (property === undefined) {\n                            property = (model.index === null) ? table.fields.keyPathField : model.index;\n                        }\n\n                        var a = _get(function (event, resolve) {\n                            var result = event.target.result;\n\n                            //if record exists\n                            if (result) {\n\n                                //passing result through filter\n                                if (!_checkResult(result)) {\n                                    result.continue();\n                                    return false;\n                                }\n\n                                count++;\n\n                                value = self.helper.getPropertyValue(property, result.value);\n                                if (typeof value === 'number') {\n                                    sum = sum + value;\n                                }\n\n                                result.continue();\n\n                            } else {\n                                average = (sum === 0 && count === 0) ? 0 : sum / count;\n                                resolve(average);\n                            }\n\n                        });\n\n                        return a;\n                    };\n\n                    aggregate.custom = function (callback, endCallback) {\n                        if (typeof callback !== 'function') {\n                            throw \"Parameter passed to custom aggregate must be of function type\";\n                        }\n\n                        var outcome = 0;\n\n                        var cust = _get(function (event, resolve, reject) {\n                            var result = event.target.result;\n\n                            if (result) {\n                                //passing result through filter\n                                if (!_checkResult(result)) {\n                                    result.continue();\n                                    return false;\n                                }\n\n                                try {\n                                    outcome = callback(outcome, angular.copy(result.value));\n                                } catch (exception) {\n                                    transaction.abort();\n                                    reject(exception);\n                                    return false;\n                                }\n\n                                result.continue();\n\n                            } else {\n                                if (typeof endCallback === 'function') {\n                                    outcome = endCallback(outcome);\n                                }\n\n                                resolve(outcome);\n                            }\n                        });\n\n                        return cust;\n                    };\n                }\n\n                model.getAggregate = function () {\n                    var count = 0;\n                    var outcome = {};\n\n                    var ag = _get(function (event, resolve, reject) {\n                        var result = event.target.result;\n\n                        if (result) {\n                            //passing result through filter\n                            if (!_checkResult(result)) {\n                                result.continue();\n                                return false;\n                            }\n\n                            count = count + 1;\n\n                            try {\n                                outcome = aggregateObject.getSums(outcome, result.value);\n                                outcome = aggregateObject.getAverages(outcome, result.value, false);\n                                outcome = aggregateObject.getMins(outcome, result.value);\n                                outcome = aggregateObject.getMaxs(outcome, result.value);\n                                outcome = aggregateObject.getCustoms(outcome, result.value, false);\n\n                            } catch (exception) {\n                                reject(exception);\n                            }\n\n\n                            result.continue();\n                        } else {\n                            outcome = aggregateObject.getAverages(outcome, count, true);\n                            outcome = aggregateObject.getCustoms(outcome, count, true);\n                            resolve(outcome);\n                        }\n                    });\n\n                    return ag;\n                };\n\n                model.aggregate = new CreateAggregate();\n\n            }\n\n\n            //function sets the index configure values(unique/multientry)\n            function _getFieldConfig(field) {\n                var config = {};\n                if (field.hasOwnProperty('unique')) {\n                    if (field.unique) {\n                        config.unique = true;\n                    }\n                }\n\n                if (field.hasOwnProperty('multiEntry')) {\n                    if (field.multiEntry) {\n                        config.multiEntry = true;\n                    }\n                }\n                return config;\n            }\n\n            //function sets keyPathValue if not provided\n            function _getIndexValue(field) {\n                if (field.keyPathValue === undefined) {\n                    return field.name;\n                }\n\n                return field.keyPathValue;\n            }\n\n            function _createModelInstance(db, table) {\n                var objectStore;\n                if (db.objectStoreNames.contains(table.name)) {\n                    objectStore = db.transaction([table.name]).objectStore(table.name);\n\n                    //checking if table given exists in indexeddb\n                    if (objectStore.keyPath !== table.fields.keyPathField) {\n                        table.fields.keyPathField = objectStore.keyPath;\n                    }\n\n                    self.models[table.name] = {};\n                    //setting getter instance of object as new CreateModel instance\n                    Object.defineProperty(self.models, table.name, {\n                        get: function () {\n                            return new CreateModel(table);\n                        }\n                    });\n                }\n            }\n\n            /**\n             * Private : function creates tables when upgrade function is fired\n             * @param  {event.target.result} db [it of result of event of upgradedneeded]\n             */\n            function _createTables(target) {\n                var config, db, transaction;\n                db = target.result;\n                transaction = target.transaction;\n\n                self.tables.forEach(function (table) {\n                    var objectStore;\n\n                    //if table does not exist then creating it\n                    if (!db.objectStoreNames.contains(table.name)) {\n\n                        //setting auto increment to keyPath\n                        objectStore = db.createObjectStore(table.name, {\n                            keyPath: table.fields.keyPathField,\n                            autoIncrement: true\n                        });\n\n                        //creating other fields/indexes\n                        table.fields.other.forEach(function (field) {\n                            var indexValue = _getIndexValue(field);\n                            config = _getFieldConfig(field); //fetching configuration against the index\n                            objectStore.createIndex(field.name, indexValue, config);\n                        });\n\n                    } else {\n                        objectStore = transaction.objectStore(table.name);\n\n                        //creating new fields/indexes\n                        table.fields.other.forEach(function (field) {\n                            var indexValue = _getIndexValue(field);\n                            config = _getFieldConfig(field); //fetching configuration against the index\n                            if (!objectStore.indexNames.contains(field.name)) {\n                                objectStore.createIndex(field.name, indexValue, config);\n                            }\n                        });\n                    }\n\n                    self.models[table.name] = {};\n                    //setting getter instance of object as new CreateModel instance\n                    Object.defineProperty(self.models, table.name, {\n                        get: function () {\n                            return new CreateModel(table);\n                        }\n                    });\n                });\n            }\n\n            //private : function sets the fields(indexes) and keyPath field value of table\n            function _setFields(fields, tableName) {\n                var j, field, keyPath, newFields, fieldNames;\n                keyPath = false;\n                newFields = {};\n                newFields.other = [];\n                fieldNames = [];\n\n                //setting other fields and keyPath Field\n                for (j = fields.length - 1; j >= 0; j--) {\n                    field = fields[j];\n\n                    //validating field properties\n                    if (typeof field.name !== 'string') {\n                        throw \"Field/Index name must be of string type\";\n                    }\n\n                    if (fieldNames.indexOf(field.name) !== -1) {\n                        throw \"Field/Index name already exists\";\n                    }\n\n                    //pushing to feildNames to check further fields of tables\n                    fieldNames.push(field.name);\n\n                    //checking field for keyPath property\n                    if (field.hasOwnProperty('keyPath')) {\n                        if (field.keyPath === true) {\n\n                            //checking if keyPath has already being set\n                            if (keyPath === true) {\n                                throw \"Error multiple keyPath defined in table \" + tableName;\n                            }\n                            //setting keyPath as this field \n                            newFields.keyPathField = field.name;\n                            keyPath = true; //setting keyPath flag as keyPath has been defined\n\n                        } else {\n                            //adding field to other array stating them as indexes\n                            newFields.other.push(field);\n                        }\n                    } else {\n                        //adding field to other array stating them as indexes\n                        newFields.other.push(field);\n                    }\n                }\n\n                //if no keyPath field was set then setting default as '_id'\n                if (!keyPath) {\n                    newFields.keyPathField = '_id';\n                }\n\n                return newFields;\n            }\n\n            //private : function prepares tables for creating them db and to create models against them\n            function _setTables() {\n                var i, table, fields, tableNames;\n                tableNames = [];\n                //for each table\n                for (i = self.tables.length - 1; i >= 0; i--) {\n\n                    table = self.tables[i];\n\n                    //validating table name type\n                    if (typeof table.name !== 'string') {\n                        throw \"Table/ObjectStore name must be of string type\";\n                    }\n\n                    if (tableNames.indexOf(table.name) !== -1) {\n                        throw \"Repeated Table/ObjectStore name \" + table.name;\n                    }\n\n                    //pushing to array to check further table names\n                    tableNames.push(table.name);\n\n                    table.hasTimeStamp = false; //default timestamps value as false\n\n                    //fetching fields data\n                    fields = _setFields(table.fields, table.name);\n                    table.fields = fields;\n\n                    //checking if timestamps property is set\n                    if (table.timeStamps === true) {\n                        table.hasTimeStamp = true; //setting timestamps to be true\n\n                        //checking if indexing on timestamps needs to be done\n                        if (table.indexOnTimeStamps === true) {\n\n                            //creating indexing on timestamps with multientry as configuration\n                            table.fields.other.push({\n                                name: 'updatedAt',\n                                keyPathValue: 'updatedAt',\n                                multiEntry: true\n                            });\n                            table.fields.other.push({\n                                name: 'createdAt',\n                                keyPathValue: 'createdAt',\n                                multiEntry: true\n                            });\n                        }\n                    }\n                }\n            }\n\n            _setTables();\n\n            self.open.then(function (event) {\n                try {\n                    var l, table;\n                    //when database is being upgraded\n                    if (event.type === \"upgradeneeded\") {\n                        _createTables(event.target);\n                    } else {\n                        for (l = self.tables.length - 1; l >= 0; l--) {\n                            table = self.tables[l];\n                            _createModelInstance(event.target.result, table);\n\n                        }\n                    }\n\n                } catch (exception) {\n                    qRej(exception);\n                }\n                qRes(self);\n\n            }).catch(function (event) {\n                qRej(event);\n            });\n\n        }\n\n        return $q(function (res, rej) {\n            var a = new CreateTables(dbName, dbVersion, dbTables, res, rej);\n            return a;\n        });\n    }\n\n    initialize.$inject = ['$q'];\n\n    function setDbName(name) {\n        dbName = name;\n    }\n\n    function setDbTables(tables) {\n        dbTables = tables;\n    }\n\n    function setDbVersion(version) {\n        dbVersion = version;\n    }\n\n\n    return {\n        setDbName: setDbName,\n        setDbVersion: setDbVersion,\n        setDbTables: setDbTables,\n        $get: initialize\n    };\n\n\n}\n\nindexeddbProvider.$inject = ['$windowProvider'];\nangular.module('indexed-db', []);\nangular.module('indexed-db').provider('indexeddb', indexeddbProvider);\n"],"sourceRoot":"/source/"}